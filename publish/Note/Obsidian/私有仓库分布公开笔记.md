---
public: true
TODO: true
edit:
  - 2026-01-09
---
# 1. å‡†å¤‡
- ç§æœ‰ä»“åº“private
- å…¬å¼€ä»“åº“publicundefined
- å‘å¸ƒè„šæœ¬deploy.py
- obsidianæ’ä»¶shell commander

# 2. å‡†å¤‡å·¥ä½œ
- å°†deploy.pyè„šæœ¬æ”¾åœ¨publicä»“åº“æ ¹ç›®å½•ä¸‹
```python
import os
import shutil
import subprocess
import sys       # <--- ç¡®ä¿å¯¼å…¥äº† sys
import json
import frontmatter

# =======================================================
# ğŸ‘‡ã€æ–°å¢ã€‘åŠ å…¥è¿™è¡Œä»£ç ï¼Œå¼ºåˆ¶è®© Python è¾“å‡º UTF-8ï¼Œè§£å†³ emoji æŠ¥é”™
sys.stdout.reconfigure(encoding='utf-8')
# =======================================================

# ================= âš™ï¸ é…ç½®åŒºåŸŸ =================

# 1. ç§æœ‰ä»“åº“ï¼ˆæºï¼‰
PRIVATE_VAULT_PATH = r"D:\obsidian-gitsync\workspace"

# 2. å…¬å¼€ä»“åº“ï¼ˆç›®æ ‡ï¼‰
PUBLISH_REPO_PATH = r"D:\obsidian-gitsync\publish"

# 3. æ–‡ç« å­ç›®å½•
TARGET_SUBDIR = "publish"

# 4. è®°å½•åŒæ­¥çŠ¶æ€çš„æ¸…å•æ–‡ä»¶ï¼ˆå­˜æ”¾åœ¨ Publish ä»“åº“æ ¹ç›®å½•ï¼Œä¸ä¼šè¢«å‘å¸ƒï¼‰
MANIFEST_FILE = ".sync_manifest.json"

# ===============================================

def is_public(file_path):
    """è¯»å–æ–‡ä»¶ YAML Header"""
    try:
        post = frontmatter.load(file_path)
        return post.get('public') is True
    except Exception:
        return False

def load_manifest():
    """è¯»å–ä¸Šæ¬¡åŒæ­¥çš„æ–‡ä»¶åˆ—è¡¨"""
    manifest_path = os.path.join(PUBLISH_REPO_PATH, MANIFEST_FILE)
    if os.path.exists(manifest_path):
        try:
            with open(manifest_path, 'r', encoding='utf-8') as f:
                return set(json.load(f))
        except:
            return set()
    return set()

def save_manifest(file_list):
    """ä¿å­˜æœ¬æ¬¡åŒæ­¥çš„æ–‡ä»¶åˆ—è¡¨"""
    manifest_path = os.path.join(PUBLISH_REPO_PATH, MANIFEST_FILE)
    with open(manifest_path, 'w', encoding='utf-8') as f:
        json.dump(list(file_list), f, indent=2, ensure_ascii=False)

def sync_files_safely():
    dest_base_dir = os.path.join(PUBLISH_REPO_PATH, TARGET_SUBDIR)
    
    # 1. è·å–å½“å‰æ‰€æœ‰éœ€è¦åŒæ­¥çš„æ–‡ä»¶ (Current State)
    # å­˜å‚¨çš„æ˜¯ç›¸å¯¹äº TARGET_SUBDIR çš„è·¯å¾„
    current_sync_files = set()
    
    print("ğŸ“¥ æ‰«æç§æœ‰ä»“åº“ä¸­æ ‡è®°ä¸º Public çš„æ–‡ä»¶...")
    
    # ä¸´æ—¶å­—å…¸ç”¨äºå­˜å‚¨æºæ–‡ä»¶è·¯å¾„ï¼Œæ–¹ä¾¿åç»­å¤åˆ¶
    # Key: ç›¸å¯¹è·¯å¾„, Value: ç»å¯¹æºè·¯å¾„
    files_to_copy = {}

    for root, dirs, files in os.walk(PRIVATE_VAULT_PATH):
        dirs[:] = [d for d in dirs if not d.startswith('.')]
        for file in files:
            if file.endswith(".md"):
                source_abs_path = os.path.join(root, file)
                if is_public(source_abs_path):
                    # è®¡ç®—ç›¸å¯¹ç»“æ„è·¯å¾„
                    rel_path = os.path.relpath(source_abs_path, PRIVATE_VAULT_PATH)
                    current_sync_files.add(rel_path)
                    files_to_copy[rel_path] = source_abs_path

    # 2. è¯»å–ä¸Šæ¬¡çš„æ¸…å• (Previous State)
    previous_sync_files = load_manifest()

    # 3. è®¡ç®—éœ€è¦åˆ é™¤çš„æ–‡ä»¶ (ä¸Šæ¬¡æœ‰ï¼Œè¿™æ¬¡æ²¡æœ‰çš„)
    files_to_delete = previous_sync_files - current_sync_files
    
    # 4. æ‰§è¡Œåˆ é™¤ (åªåˆ é™¤è„šæœ¬è‡ªå·±äº§ç”Ÿè¿‡çš„æ—§æ–‡ä»¶)
    if files_to_delete:
        print(f"ğŸ§¹ æ£€æµ‹åˆ° {len(files_to_delete)} ä¸ªæ–‡ä»¶éœ€è¦è¢«ç§»é™¤...")
        for rel_path in files_to_delete:
            full_path_to_delete = os.path.join(dest_base_dir, rel_path)
            if os.path.exists(full_path_to_delete):
                try:
                    os.remove(full_path_to_delete)
                    print(f"   âŒ å·²ç§»é™¤æ—§æ–‡ä»¶: {rel_path}")
                except OSError as e:
                    print(f"   âš ï¸ ç§»é™¤å¤±è´¥: {rel_path}, {e}")
            
            # å°è¯•æ¸…ç†ç©ºæ–‡ä»¶å¤¹ (å¯é€‰)
            # å¦‚æœåˆ é™¤äº†æ–‡ä»¶å¯¼è‡´æ–‡ä»¶å¤¹ä¸ºç©ºï¼Œé¡ºæ‰‹åˆ æ‰æ–‡ä»¶å¤¹
            parent_dir = os.path.dirname(full_path_to_delete)
            if os.path.exists(parent_dir) and not os.listdir(parent_dir):
                try:
                    os.rmdir(parent_dir)
                    print(f"   ğŸ“‚ ç§»é™¤ç©ºç›®å½•: {parent_dir}")
                except:
                    pass

    # 5. æ‰§è¡Œå¤åˆ¶/æ›´æ–° (è¦†ç›–å†™å…¥)
    print(f"ğŸš€ å¼€å§‹åŒæ­¥ {len(current_sync_files)} ä¸ªæ–‡ä»¶...")
    for rel_path, src_path in files_to_copy.items():
        dest_path = os.path.join(dest_base_dir, rel_path)
        
        # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        
        # å¤åˆ¶æ–‡ä»¶
        shutil.copy2(src_path, dest_path)
        # print(f"   âœ… åŒæ­¥: {rel_path}") # æ—¥å¿—å¤ªé•¿å¯ä»¥æ³¨é‡Šæ‰

    # 6. ä¿å­˜æ–°çš„æ¸…å•
    save_manifest(current_sync_files)
    print("ğŸ’¾ åŒæ­¥æ¸…å•å·²æ›´æ–°ã€‚")
    
    return len(current_sync_files) + len(files_to_delete)

def git_push():
    # ... (Git æ¨é€éƒ¨åˆ†ä»£ç ä¿æŒä¸å˜) ...
    print("\nğŸš€ æ­£åœ¨æ£€æŸ¥ Git çŠ¶æ€...")
    os.chdir(PUBLISH_REPO_PATH)
    try:
        subprocess.run(["git", "add", "."], check=True)
        status = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True)
        if not status.stdout.strip():
            print("â˜•ï¸ å†…å®¹æ— å˜åŒ–ï¼Œæ— éœ€æ¨é€ã€‚")
            return
        subprocess.run(["git", "commit", "-m", "Auto deploy from Private Vault"], check=True)
        subprocess.run(["git", "push"], check=True)
        print("ğŸŒŸ å‘å¸ƒæˆåŠŸï¼")
    except subprocess.CalledProcessError as e:
        print(f"âŒ Git æ“ä½œå‡ºé”™: {e}")

if __name__ == "__main__":
    if sync_files_safely() > 0:
        git_push()
    else:
        # å³ä½¿æ²¡æœ‰æ–‡ä»¶å˜åŠ¨ï¼Œå¦‚æœæœ‰æ–‡ä»¶è¢«åˆ é™¤äº†ï¼Œsync_files_safely ä¹Ÿä¼šè¿”å› > 0
        # åªæœ‰åœ¨å®Œå…¨æ²¡æœ‰ä»»ä½• Public æ–‡ä»¶ä¸”æ²¡æœ‰åˆ é™¤æ“ä½œæ—¶ï¼Œæ‰ä¼šåˆ°è¿™é‡Œ
        print("ğŸ” æ‰«æå®Œæ¯•ï¼Œæœªæ£€æµ‹åˆ°å˜åŠ¨ã€‚")
```
- åœ¨obsidianä¸­å®‰è£…ç¬¬ä¸‰æ–¹æ’ä»¶shell commander
- æ ¹æ®è‡ªå·±ç”µè„‘ä¸Šçš„è·¯å¾„æ·»åŠ pyè„šæœ¬å’ŒshellæŒ‡ä»¤
  ```shell
  "C:\Users\xxx\AppData\Local\Programs\Python\Python313\python.exe" "D:\path\to\valut\deploy.py"
  ```
# 3. å·¥ä½œæµ
1. ç§æœ‰ä»“åº“ä¸­ç¼–è¾‘ç¬”è®°
   åœ¨yamlä¸­æ·»åŠ public:trueçš„æ ‡è®°
2. è¿è¡ŒshellæŒ‡ä»¤